## setRefClass("PropertyWidgetQt", contains = "PropertyWidget")
PropertySetWQT.gen <- setRefClass("PropertySetWidgetQt",
                                  contains = c("PropertySet", "PropertyWidgetQt"))

ColorWQT.gen <- setRefClass("ColorWidgetQt", contains = c("Color", "PropertyWidgetQt"))
ColorWQT.gen$methods(
  widget = function(){
    C
  }
  )

## ColorEnumWQT.gen <- setRefClass("ColorEnumWidgetQt", contains = c("ColorEnum", "PropertyWidgetQt"))
## GlyphEnumWQT.gen <- setRefClass("GlyphEnumWidgetQt", contains = c("GlyphEnum", "PropertyWidgetQt"))
## SingleEnumWQT.gen <- setRefClass("SingleEnumWidgetQt",
##                                  contains = c("SingleEnum", "PropertyWidgetQt"))
## MultipleEnumWQT.gen <- setRefClass("MultilpleEnumWidgetQt",
##                                    contains = c("MultipleEnum", "PropertyWidgetQt"))
## PositiveIntegerWQT.gen <- setRefClass("PositiveIntegerWidgetQt",
##                                       contains = c("PositiveInteger", "PropertyWidgetQt"))
## NegativeIntegerWTQ.gen <- setRefClass("NegativeIntegerWidgetQt",
##                                       contains = c("NegativeInteger", "PropertyWidgetQt"))
## NonpositiveIntegerWQT.gen <- setRefClass("NonpositiveIntegerWidgetQt",
##                                          contains = c("NonpositiveInteger", "PropertyWidgetQt"))
## NonnegativeIntegerWQT.gen <- setRefClass("NonnegativeIntegerWidgetQt",
##                                           contains = c("NonnegativeInteger", "PropertyWidgetQt"))
## NumericWithRangeWQT.gen <- setRefClass("NumericWithRangeWidgetQt",
##                                        contains = c("NumericWithRange", "PropertyWidgetQt"))
## ## setRefClass("IntegerWithRangeWidgetQt", contains = c("IntegerWithRange", "PropertyWidgetQt"))
## NumericWith01WQT.gen <- setRefClass("NumericWithMin0Max1WidgetQt",
##                                     contains = c("NumericWithMin0Max1", "PropertyWidgetQt"))



## define all widget
qsetClass("ColorWidgetQt", Qt$QWidget, function(obj, par, parent = NULL) {
  super(parent)
  this$obj <- obj; this$par <- par
  initColor <- obj$field(par)
  #parInfo <- obj$output()$parinfo[names(obj$output()$parinfo) == par]
  #this$parLabel <- Qt$QLabel(paste(parInfo,":",sep=""))
  #parLabel$setToolTip(
  #  obj$output()$tooltipinfo[names(obj$output()$tooltipinfo) == par])
  this$parSwatch <- Qt$QPushButton()
  parSwatch$setAutoFillBackground(TRUE)
  parSwatch$setFocusPolicy(Qt$Qt$NoFocus)
  parSwatch$setStyleSheet(paste("background-color:",initColor,sep=""))
  this$parEdit <- Qt$QLineEdit(initColor)
  this$col <- Qt$QColorDialog()

  qconnect(parSwatch, "clicked", function() {
    col$show()
  })

  qconnect(col, "accepted", function() {
    #parSwatch$setStyleSheet(paste("background-color:",
    #  col$currentColor$name(),sep=""))
    #parEdit$setText(col$currentColor$name())
    setValue(col$currentColor$name())
  })

  qconnect(parEdit, "editingFinished", function() {
    setValue(parEdit$text)
  })

  lyt <- Qt$QHBoxLayout()
  #lyt$addWidget(parLabel,1,Qt$Qt$AlignRight)
  lyt$addWidget(parSwatch)
  lyt$addWidget(parEdit)

  setLayout(lyt)
})

qsetMethod("getPar", ColorWidgetQt, function() {
  par
})

qsetMethod("getValue", ColorWidgetQt, function() {
  parEdit$text
})

# also updates the obj object with new color
qsetMethod("setValue", ColorWidgetQt, function(clr) {
  if(Qt$QColor$isValidColor(clr)) {
    parSwatch$setStyleSheet(paste("background-color:",clr,sep=""))
    parEdit$setText(clr)
    eval(parse(text=paste("obj$",par," <- parEdit$text",sep="")))
  } else {
    parEdit$setText("")
    parLabel$setFocus(Qt$Qt$OtherFocusReason)
    parEdit$setPlaceholderText("Error: Invalid color entered")
  }
})

qsetMethod("setDefault", ColorWidgetQt, function() {
  clr <- obj$field(par)
  parSwatch$setStyleSheet(paste("background-color:",clr,sep=""))
  parEdit$setText(clr)  
})




# widget to handle changing colors
qsetClass("ColorEnumParWidget", Qt$QWidget, function(obj, par, parent = NULL) {
  super(parent)
  this$obj <- obj; this$par <- par

  initColor <- obj$field(par)

  this$colors <- eval(parse(text=paste("levels(obj$",par,")",sep="")))
  
  this$dropList <- Qt$QComboBox()
  sapply(colors, function(i) {
    pmap <- Qt$QPixmap(30,20)
    pmap$fill(Qt$QColor(i))
    icon <- Qt$QIcon(pmap)
    dropList$addItem(icon,i)
  })
  dropList$setCurrentIndex(which(colors == initColor) - 1)
  dropList$setIconSize(Qt$QSize(40,20))  

  # change obj when user changes level
  qconnect(dropList, "currentIndexChanged(QString)", function(idx) {
    eval(parse(text=paste("obj$",par,
                 " <- dropList$currentText",sep="")))
  })

  lyt <- Qt$QHBoxLayout()
  lyt$addWidget(dropList)
  
  setLayout(lyt)
})

qsetMethod("getPar", ColorEnumParWidget, function() {
  par
})

qsetMethod("getValue", ColorEnumParWidget, function() {
  dropList$currentText
})

qsetMethod("setValue", ColorEnumParWidget, function(val) {
  if(val %in% colors) dropList$setCurrentIndex(which(colors == val) - 1)
})

qsetMethod("setDefault", ColorEnumParWidget, function() {
  val <- obj$field(par)
  dropList$setCurrentIndex(which(colors == val) - 1)
})



# widget to handle changing colors
qsetClass("GlyphEnumParWidget", Qt$QWidget, function(obj, par, parent = NULL) {
  super(parent)
  this$obj <- obj; this$par <- par

  initLvl <- obj$field(par)

  this$levels <- eval(parse(text=paste("levels(obj$",par,")",sep="")))
  
  this$dropList <- Qt$QComboBox()
  icons <- eval(parse(text=paste("icons(obj$",par,")",sep="")))
  sapply(seq_along(levels), function(i) {
    dropList$addItem(icons[[i]],levels[i])
  })
  dropList$setCurrentIndex(which(levels == initLvl) - 1)
  dropList$setIconSize(Qt$QSize(40,20))  

  # change obj when user changes level
  qconnect(dropList, "currentIndexChanged(QString)", function(idx) {
    eval(parse(text=paste("obj$",par,
                 " <- dropList$currentText",sep="")))
  })
  lyt <- Qt$QHBoxLayout()
  lyt$addWidget(dropList)
  setLayout(lyt)
})

qsetMethod("getPar", GlyphEnumParWidget, function() {
  par
})

qsetMethod("getValue", GlyphEnumParWidget, function() {
  dropList$currentText
})

qsetMethod("setValue", GlyphEnumParWidget, function(val) {
  if(val %in% levels) dropList$setCurrentIndex(which(levels == val) - 1)
})

qsetMethod("setDefault", GlyphEnumParWidget, function() {
  val <- obj$field(par)
  dropList$setCurrentIndex(which(levels == val) - 1)
})

# widget for changing numeric values (general for any numeric range, but
# for now hard-coded for a 0-1 range)
qsetClass("RangeParWidget", Qt$QWidget, function(obj, par, type,parent = NULL, decimal.extra = 3)
{
  super(parent)
  this$obj <- obj; this$par <- par; this$type <- type

  initVal <- obj$field(par)
  #this$minVal <- eval(parse(text=paste("obj$",par,"@min",sep="")))
  this$minVal <- initVal@min
  #this$maxVal <- eval(parse(text=paste("obj$",par,"@max",sep="")))
  this$maxVal <- initVal@max
  
  #parInfo <- obj$output()$parinfo[names(obj$output()$parinfo) == par]
  #this$parLabel <- Qt$QLabel(paste(parInfo,":",sep=""))
  #parLabel$setToolTip(
  #  obj$output()$tooltipinfo[names(obj$output()$tooltipinfo) == par])
  if(type == "double") {
    this$spin <- Qt$QDoubleSpinBox()
    spin$setDecimals(decimalplaces(minVal) + decimal.extra)
    spin$setSingleStep((maxVal - minVal)/100)
  }
  if(type == "integer"){
    this$spin <- Qt$QSpinBox()
    spin$setSingleStep(1)
  }

  spin$setRange(minVal, maxVal)
  spin$setValue(initVal)

  # slider -- only supports integers, so need to adjust values
  this$sl <- Qt$QSlider(Qt$Qt$Horizontal)

  if(type == "double") {
    sl$setRange(0,100)
    sl$setValue(100*(initVal - minVal)/(maxVal - minVal))
  }
  if(type == "integer"){
    sl$setSingleStep(1)
    sl$setRange(minVal,maxVal)
    sl$setValue(initVal)
  }


  if(type == "double"){
    qconnect(spin, "valueChanged(double)", function(val) {
      sl$setValue(as.integer(100*(val - minVal)/(maxVal - minVal)))
    })
  }
  if(type == "integer"){
    qconnect(spin, "valueChanged(int)", function(val) {
      sl$setValue(val)
    })
  }
  # update spinbox when slider changes, and update the obj
  qconnect(sl, "valueChanged", function(val) {
    if(type == "double") {
      spin$setValue(val / 100 * (maxVal - minVal) + minVal)
    } else {
      spin$setValue(val)
    }
    eval(parse(text=paste("obj$",par," <- spin$value",sep="")))
  })
  
  lyt <- Qt$QHBoxLayout()
  #lyt$addWidget(parLabel,1,Qt$Qt$AlignRight)
  lyt$addWidget(spin)
  lyt$addWidget(sl)

  setLayout(lyt)
})

qsetMethod("getPar", RangeParWidget, function() {
  par
})

qsetMethod("getValue", RangeParWidget, function() {
  spin$value
})

qsetMethod("setValue", RangeParWidget, function(val) {
  spin$setValue(val)
})

qsetMethod("setDefault", RangeParWidget, function() {
  val <- obj$field(par)
  spin$setValue(val)
})

# widget to change levels from a class extending Enum
qsetClass("SingleEnumParWidget", Qt$QWidget, function(obj, par, parent = NULL)
{
  super(parent)
  this$obj <- obj; this$par <- par

  initLvl <- obj$field(par)
  
  this$levels <- eval(parse(text=paste("levels(obj$",par,")",sep="")))
  #parInfo <- obj$output()$parinfo[names(obj$output()$parinfo) == par]
  #this$parLabel <- Qt$QLabel(paste(parInfo,":",sep=""))
  #parLabel$setToolTip(
  #  obj$output()$tooltipinfo[names(obj$output()$tooltipinfo) == par])

  this$dropList <- Qt$QComboBox()
  sapply(levels, dropList$addItem)
  dropList$setCurrentIndex(which(levels == initLvl) - 1)

  # change obj when user changes level
  qconnect(dropList, "currentIndexChanged(QString)", function(idx) {
    eval(parse(text=paste("obj$",par,
                 " <- dropList$currentText",sep="")))
  })

  lyt <- Qt$QHBoxLayout()
  #lyt$addWidget(parLabel,1,Qt$Qt$AlignRight)
  lyt$addWidget(dropList)

  setLayout(lyt)
})

qsetMethod("getPar", SingleEnumParWidget, function() {
  par
})

qsetMethod("getValue", SingleEnumParWidget, function() {
  dropList$currentText
})

qsetMethod("setValue", SingleEnumParWidget, function(val) {
  if(val %in% levels) dropList$setCurrentIndex(which(levels == val) - 1)
})

qsetMethod("setDefault", SingleEnumParWidget, function() {
  val <- obj$field(par)
  dropList$setCurrentIndex(which(levels == val) - 1)
})


# widget to change levels from a class extending Enum with ability to
# select multiple levels
qsetClass("MultEnumParWidget", Qt$QWidget, function(obj, par, parent = NULL)
{
  super(parent)
  this$obj <- obj; this$par <- par

  initVal <- obj$field(par)
  
  this$levels <- eval(parse(text=paste("levels(obj$",par,")",sep="")))
  this$currentVal <- levels %in% initVal
  #parInfo <- obj$output()$parinfo[names(obj$output()$parinfo) == par]
  #this$parLabel <- Qt$QLabel(paste(parInfo,":",sep=""))
  #parLabel$setToolTip(
  #  obj$output()$tooltipinfo[names(obj$output()$tooltipinfo) == par])
  
  lyt <- Qt$QGridLayout()

  this$bg <- Qt$QButtonGroup()
  bg$setExclusive(FALSE)

  # initiate buttons, and check those that are within the current value
  sapply(seq_along(levels), function(i) {
    button <- Qt$QCheckBox(levels[i])
    lyt$addWidget(button, floor((i-1)/4), (i-1) %% 4)
    bg$addButton(button, i)
    bg$button(i)$setChecked(currentVal[i])
  })

  # change obj when user changes level
  qconnect(bg, "buttonClicked(int)", function(id) {
    currentVal[id] <<- bg$button(id)$checked
    eval(parse(text=paste("obj$",par," <- levels[currentVal]",
                   sep="")))
  })

  #lyt <- Qt$QHBoxLayout()
  #lyt$addWidget(parLabel,1,Qt$Qt$AlignRight)
  #lyt$addWidget(dropList)

  setLayout(lyt)
})

qsetMethod("getPar", MultEnumParWidget, function() {
  par
})

qsetMethod("getValue", MultEnumParWidget, function() {
  levels[currentVal]
})

qsetMethod("setValue", MultEnumParWidget, function(val) {
  if(all(val %in% levels)) {
    currentVal <- levels %in% val
    sapply(seq_along(levels), function(i) {
      bg$button(i)$setChecked(currentVal[i])
    })
    eval(parse(text=paste("obj$",par," <- levels[currentVal]",sep="")))
  } else {
    stop("Error: one or more levels specified are not valid")
  }
})

qsetMethod("setDefault", MultEnumParWidget, function() {
  val <- obj$field(par)
  currentVal <- levels %in% val
  sapply(seq_along(levels), function(i) {
    bg$button(i)$setChecked(currentVal[i])
  })
})

qsetClass("logicalParWidget", Qt$QWidget, function(obj, par, parent = NULL)
{
  super(parent)
  this$obj <- obj; this$par <- par

  initVal <- obj$field(par)
  
  this$levels <- "TRUE"
  this$currentVal <- levels %in% initVal
  #parInfo <- obj$output()$parinfo[names(obj$output()$parinfo) == par]
  #this$parLabel <- Qt$QLabel(paste(parInfo,":",sep=""))
  #parLabel$setToolTip(
  #  obj$output()$tooltipinfo[names(obj$output()$tooltipinfo) == par])
  
  lyt <- Qt$QGridLayout()

  this$bg <- Qt$QButtonGroup()
  bg$setExclusive(FALSE)
  # initiate buttons, and check those that are within the current value
  sapply(seq_along(levels), function(i) {
    button <- Qt$QCheckBox(levels[i])
    lyt$addWidget(button, floor((i-1)/4), (i-1) %% 4)
    bg$addButton(button, i)
    bg$button(i)$setChecked(currentVal[i])
  })

  # change obj when user changes level
  qconnect(bg, "buttonClicked(int)", function(id) {
    currentVal[id] <<- bg$button(id)$checked
    eval(parse(text=paste("obj$",par," <- ",!as.logical(levels),
                   sep="")))
  })

  #lyt <- Qt$QHBoxLayout()
  #lyt$addWidget(parLabel,1,Qt$Qt$AlignRight)
  #lyt$addWidget(dropList)

  setLayout(lyt)
})

qsetMethod("getPar", logicalParWidget, function() {
  par
})

qsetMethod("getValue", logicalParWidget, function() {
  levels[currentVal]
})

qsetMethod("setValue", logicalParWidget, function(val) {
  if(all(val %in% levels)) {
    currentVal <- levels %in% val
    sapply(seq_along(levels), function(i) {
      bg$button(i)$setChecked(currentVal[i])
    })
    eval(parse(text=paste("obj$",par," <- levels[currentVal]",sep="")))
  } else {
    stop("Error: one or more levels specified are not valid")
  }
})

qsetMethod("setDefault", logicalParWidget, function() {
  val <- obj$field(par)
  currentVal <- levels %in% val
  sapply(seq_along(levels), function(i) {
    bg$button(i)$setChecked(currentVal[i])
  })
})

# widget for changing integer values (obselete at this point since there
# are not parameters of this type)
qsetClass("IntParWidget", Qt$QWidget, function(obj, par, type, parent = NULL)
{
  super(parent)
  this$obj <- obj; this$par <- par; this$type <- type

  initVal <- obj$field(par)

  #parInfo <- obj$output()$parinfo[names(obj$output()$parinfo) == par]
  #this$parLabel <- Qt$QLabel(paste(parInfo,":",sep=""))
  #parLabel$setToolTip(
  #  obj$output()$tooltipinfo[names(obj$output()$tooltipinfo) == par])

  this$spin <- Qt$QSpinBox()
  if(type == "Negati") {
    spin$setMinimum(-999999)
    spin$setMaximum(-1)
  } else if(type == "Positi") {
    spin$setMinimum(1)
    spin$setMaximum(999999)
  } else if(type == "Nonneg") {
    spin$setMinimum(0)
    spin$setMaximum(999999)
  } else {
    spin$setMinimum(-999999)
    spin$setMaximum(0)
  }
  spin$setValue(initVal)

  # update obj when spinbox changes
  qconnect(spin, "valueChanged(int)", function(val) {
    eval(parse(text=paste("obj$",par," <- spin$value",sep="")))
  })

  lyt <- Qt$QHBoxLayout()
  #lyt$addWidget(parLabel,1,Qt$Qt$AlignRight)
  lyt$addWidget(spin)

  setLayout(lyt)
})

qsetMethod("getPar", IntParWidget, function() {
  par
})

qsetMethod("getValue", IntParWidget, function() {
  spin$value
})

qsetMethod("setValue", IntParWidget, function(val) {
  spin$setValue(val)
})

qsetMethod("setDefault", IntParWidget, function() {
  val <- obj$field(par)
  spin$setValue(val)
})



# widget to handle changing character strings
qsetClass("CharParWidget", Qt$QWidget, function(obj, par, parent = NULL) {
  super(parent)
  this$obj <- obj; this$par <- par

  initText <- obj$field(par)

  this$parEdit <- Qt$QLineEdit(initText)

  qconnect(parEdit, "editingFinished", function() {
    setValue(parEdit$text)
  })

  lyt <- Qt$QHBoxLayout()
  lyt$addWidget(parEdit)
  setLayout(lyt)
})

qsetMethod("getPar", CharParWidget, function() {
  par
})

qsetMethod("getValue", CharParWidget, function() {
  parEdit$text
})


qsetMethod("setValue", CharParWidget, function(txt) {
    parEdit$setText(txt)
    eval(parse(text=paste("obj$",par," <- parEdit$text",sep="")))
})

qsetMethod("setDefault", CharParWidget, function() {
  txt <- obj$field(par) 
  parEdit$setText(txt)  
})

# function
qsetClass("functionParWidget", Qt$QWidget, function(obj, par, parent = NULL) {
  super(parent)
  this$obj <- obj; this$par <- par

  initText <- body(obj$field(par))[2]
  initText <- deparse(initText)

  this$parEdit <- Qt$QTextEdit(initText)
  parEdit$LineWrapMode
  sort(ls(parEdit))
  fl <- tempfile()
  class(initText)

  cat(paste(initText, collapse = "\n"), file =fl)
  system(paste("less", fl))
   temp <- gsub("<-", "=", initText)
Qt$QTextEdit(temp)
  qconnect(parEdit, "editingFinished", function() {
    setValue(parEdit$text)
  })

  lyt <- Qt$QHBoxLayout()
  lyt$addWidget(parEdit)
  setLayout(lyt)
})

qsetMethod("getPar", functionParWidget, function() {
  par
})

qsetMethod("getValue", functionParWidget, function() {
  parEdit$text
})

# also updates the obj object
qsetMethod("setValue", functionParWidget, function(txt) {
    parEdit$setText(txt)
    eval(parse(text=paste("obj$",par," <- parEdit$text",sep="")))
})

qsetMethod("setDefault", functionParWidget, function() {
  txt <- body(obj$field(par))[2]
  parEdit$setText(txt)  
})

# label for a given parameter, with appropriate text and tooltip
## qsetClass("ParLabel", Qt$QLabel, function(obj, par, parent = NULL) {
##   super(parent)

##   this$obj <- obj; this$par <- par

##   ## parInfo <- obj$output()$parinfo[names(obj$output()$parinfo) == par]
##   parInfo <- par
##   setText(paste(parInfo,":",sep=""))
##   ## setToolTip(
##   ##   obj$output()$tooltipinfo[names(obj$output()$tooltipinfo) == par])
    
## })


## http://stackoverflow.com/questions/5173692/how-to-return-number-of-decimal-places-in-r
decimalplaces <- function(x) {
    if ((x %% 1) != 0) {
        nchar(strsplit(sub('0+$', '', as.character(x)), ".", fixed=TRUE)[[1]][[2]])
    } else {
        return(0)
    }
}


